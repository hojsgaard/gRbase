% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/graph_rip.R
\name{graph-rip}
\alias{graph-rip}
\alias{rip}
\alias{rip.default}
\alias{ripMAT}
\alias{junction_tree}
\alias{junction_tree.default}
\alias{junction_treeMAT}
\alias{jTree}
\alias{junctionTree}
\title{Create RIP ordering of the cliques of  an undirected graph;
create junction tree.}
\usage{
rip(object, ...)

\method{rip}{default}(object, root = NULL, nLevels = NULL, ...)

ripMAT(amat, root = NULL, nLevels = rep(2, ncol(amat)))

junction_tree(object, ...)

\method{junction_tree}{default}(object, nLevels = NULL, ...)

junction_treeMAT(amat, nLevels = rep(2, ncol(amat)), ...)

jTree(object, ...)
}
\arguments{
\item{object}{An undirected graph represented either as a
\code{graphNEL} object, an \code{igraph}, a (dense)
\code{matrix}, a (sparse) \code{dgCMatrix}.}

\item{...}{Additional arguments; currently not used}

\item{root}{A vector of variables. The first variable in the
perfect ordering will be the first variable on 'root'. The
ordering of the variables given in 'root' will be followed as
far as possible.}

\item{nLevels}{Typically, the number of levels of the variables
(nodes) when these are discrete. Used in determining the
triangulation using a "minimum clique weight heuristic". See
section 'details'.}

\item{amat}{Adjacency matrix}
}
\value{
\code{rip} returns a list (an object of class
\code{ripOrder}. A print method exists for such objects.)
}
\description{
A RIP (running intersection property) ordering of the
cliques is also called a perfect ordering. If the graph is not
chordal, then no such ordering exists.
}
\details{
The RIP ordering of the cliques of a decomposable
(i.e. chordal) graph is obtained by first ordering the
variables linearly with maximum cardinality search (by
\code{mcs}). The root argument is transfered to \code{mcs} as a
way of controlling which clique will be the first in the RIP
ordering.  The \code{junction_tree()} (and
\code{junction_tree()}) (for "junction tree") is just a wrapper
for a call of \code{triangulate()} followed by a call of
\code{rip()}.
}
\note{
The workhorse is the \code{ripMAT()} function. The
\code{nLevels} argument to the \code{rip} functions has no
meaning.
}
\section{Synonymous functions}{


For backward compatibility with downstream packages we have the
following synonymous functions:
\itemize{
\item jTree = junction_tree (Used in rags2ridges)
\item junctionTree = junction_tree
}
}

\examples{

## graphNEL
uG <- ug(~me:ve + me:al + ve:al + al:an + al:st + an:st)
mcs(uG)
rip(uG)
junction_tree(uG)

## Adjacency matrix
uG <- ug(~me:ve:al + al:an:st, result="matrix")
mcs(uG)
rip(uG)
junction_tree(uG)

## Sparse adjacency matrix
uG <- ug(c("me", "ve", "al"), c("al", "an", "st"), result="dgCMatrix")
mcs(uG)
rip(uG)
junction_tree(uG)

## Non--decomposable graph
uG <- ug(~1:2 + 2:3 + 3:4 + 4:5 + 5:1)
mcs(uG)
rip(uG)
junction_tree(uG)


}
\seealso{
\code{\link{mcs}}, \code{\link{triangulate}},
\code{\link{moralize}}, \code{\link{ug}}, \code{\link{dag}}
}
\author{
Søren Højsgaard, \email{sorenh@math.aau.dk}
}
\keyword{utilities}
