% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/graph-rip.R
\name{graph-rip}
\alias{graph-rip}
\alias{rip}
\alias{rip.default}
\alias{ripMAT}
\alias{jTree}
\alias{jTree.default}
\alias{jTreeMAT}
\alias{junctionTree}
\alias{junctionTree.default}
\alias{junctionTreeMAT}
\alias{rip.default}
\alias{ripMAT}
\alias{jTree}
\alias{jTree.default}
\alias{jTreeMAT}
\title{Create  RIP ordering of the cliques of  an undirected graph;
    create junction tree.}
\usage{
rip(object, ...)

\method{rip}{default}(object, root = NULL, nLevels = NULL, ...)

ripMAT(amat, root = NULL, nLevels = rep(2, ncol(amat)))

jTree(object, ...)

\method{jTree}{default}(object, nLevels = NULL, ...)

jTreeMAT(amat, nLevels = rep(2, ncol(amat)), ...)
}
\arguments{
\item{object}{An undirected graph represented either as a
\code{graphNEL} object, an \code{igraph}, a (dense)
\code{matrix}, a (sparse) \code{dgCMatrix}.}

\item{...}{Additional arguments; currently not used}

\item{root}{A vector of variables. The first variable in the
perfect ordering will be the first variable on 'root'. The
ordering of the variables given in 'root' will be followed as
far as possible.}

\item{nLevels}{Typically, the number of levels of the variables
(nodes) when these are discrete. Used in determining the
triangulation using a "minimum clique weight heuristic". See
section 'details'.}

\item{amat}{Adjacency matrix}
}
\value{
\code{rip} returns a list (an object of class
    \code{ripOrder}. A print method exists for such objects.)
}
\description{
A RIP (running intersection property) ordering of the
    cliques is also called a perfect ordering. If the graph is not
    chordal, then no such ordering exists.
}
\details{
The RIP ordering of the cliques of a decomposable
    (i.e. chordal) graph is obtained by first ordering the
    variables linearly with maximum cardinality search (by
    \code{mcs}). The root argument is transfered to \code{mcs} as a
    way of controlling which clique will be the first in the RIP
    ordering.  The \code{jTree()} (and \code{jTree()}) (for
    "junction tree") is just a wrapper for a call of
    \code{triangulate()} followed by a call of \code{rip()}.
}
\note{
The workhorse is the \code{ripMAT()} function. The
    \code{nLevels} argument to the \code{rip} functions has no
    meaning.
}
\examples{

## graphNEL
uG <- ug(~me:ve + me:al + ve:al + al:an + al:st + an:st)
mcs(uG)
rip(uG)
jTree(uG)

## Adjacency matrix
uG <- ug(~me:ve:al + al:an:st, result="matrix")
mcs(uG)
rip(uG)
jTree(uG)

## Sparse adjacency matrix
uG <- ug(c("me", "ve", "al"), c("al", "an", "st"), result="dgCMatrix")
mcs(uG)
rip(uG)
jTree(uG)

## Non--decomposable graph
uG <- ug(~1:2 + 2:3 + 3:4 + 4:5 + 5:1)
mcs(uG)
rip(uG)
jTree(uG)


}
\seealso{
\code{\link{mcs}} \code{\link{triangulate}}
    \code{\link{moralize}} \code{\link{ug}}, \code{\link{dag}}
}
\author{
Søren Højsgaard, \email{sorenh@math.aau.dk}
}
\keyword{utilities}
